"""Export per-language CEDICT-format files from the master database.

Produces files like dictmaster_en.txt, dictmaster_fr.txt, etc.
Best definition wins when multiple sources: dictionary > wiktextract > AI.
"""

import sqlite3
from datetime import datetime, timezone
from pathlib import Path
from typing import Optional

# Source priority: lower number = higher priority
SOURCE_PRIORITY = {
    "cedict": 1,
    "cfdict": 1,
    "handedict": 1,
    "cidict": 1,
    "jmdict": 2,
    "wiktextract": 3,
    "minimax": 4,
}

HEADER_TEMPLATE = """\
# {title}
# Generated by dictmaster from: {sources}
# Date: {date}
# Entries: {count}
# License: Mixed (see individual sources)
#   CC-CEDICT: CC BY-SA 4.0
#   CFDICT: CC BY-SA 3.0
#   HanDeDict: CC BY-SA 2.0
#   CC-CIDICT: CC BY-SA 4.0
#   Wiktextract: CC BY-SA 4.0
#   JMdict: CC BY-SA 4.0
#   MiniMax M2.5: AI-generated
#
"""

LANG_TITLES = {
    "en": "Dictmaster Chinese-English Dictionary",
    "de": "Dictmaster Chinese-German Dictionary (Chinesisch-Deutsch)",
    "fr": "Dictmaster Chinese-French Dictionary (Chinois-Français)",
    "es": "Dictmaster Chinese-Spanish Dictionary (Chino-Español)",
    "sv": "Dictmaster Chinese-Swedish Dictionary (Kinesisk-Svenska)",
    "ja": "Dictmaster Chinese-Japanese Dictionary (中日辞典)",
    "ko": "Dictmaster Chinese-Korean Dictionary (중한사전)",
    "ru": "Dictmaster Chinese-Russian Dictionary (Китайско-русский)",
    "id": "Dictmaster Chinese-Indonesian Dictionary (Tionghoa-Indonesia)",
    "vi": "Dictmaster Chinese-Vietnamese Dictionary (Từ điển Trung-Việt)",
    "tl": "Dictmaster Chinese-Tagalog Dictionary (Diksyunaryo Tsino-Tagalog)",
}


def _best_definition(definitions: list[dict]) -> str:
    """Pick the best definition from multiple sources based on priority."""
    if not definitions:
        return ""
    # Sort by source priority (lower = better)
    ranked = sorted(definitions, key=lambda d: SOURCE_PRIORITY.get(d["source"], 99))
    return ranked[0]["definition"]


def export_language(
    conn: sqlite3.Connection,
    lang: str,
    output_dir: Path,
    *,
    filename: Optional[str] = None,
) -> Path:
    """Export a single language to a CEDICT-format file.

    Args:
        conn: Database connection
        lang: ISO 639-1 language code
        output_dir: Directory to write the file
        filename: Override filename (default: dictmaster_{lang}.txt)

    Returns:
        Path to the generated file
    """
    output_dir.mkdir(parents=True, exist_ok=True)
    fname = filename or f"dictmaster_{lang}.txt"
    output_path = output_dir / fname

    # Fetch all headwords with definitions in this language
    rows = conn.execute("""
        SELECT h.traditional, h.simplified, h.pinyin,
               d.definition, d.source
        FROM headwords h
        JOIN definitions d ON d.headword_id = h.id
        WHERE d.lang = ?
        ORDER BY h.pinyin, h.simplified
    """, (lang,)).fetchall()

    # Group by headword (there may be multiple definitions from different sources)
    entries = {}  # (trad, simp, pinyin) -> [{"definition": ..., "source": ...}]
    for row in rows:
        key = (row["traditional"], row["simplified"], row["pinyin"])
        if key not in entries:
            entries[key] = []
        entries[key].append({
            "definition": row["definition"],
            "source": row["source"],
        })

    # Collect unique sources used
    sources_used = set()
    for defs in entries.values():
        for d in defs:
            sources_used.add(d["source"])

    # Write the file
    with open(output_path, "w", encoding="utf-8") as f:
        # Header
        f.write(HEADER_TEMPLATE.format(
            title=LANG_TITLES.get(lang, f"Dictmaster Chinese-{lang.upper()} Dictionary"),
            sources=", ".join(sorted(sources_used)),
            date=datetime.now(timezone.utc).strftime("%Y-%m-%d"),
            count=len(entries),
        ))

        # Entries sorted by pinyin
        for (trad, simp, pinyin), defs in sorted(entries.items(), key=lambda x: x[0][2]):
            best_def = _best_definition(defs)
            if best_def:
                f.write(f"{trad} {simp} [{pinyin}] /{best_def}/\n")

    return output_path


def export_all_languages(
    conn: sqlite3.Connection,
    output_dir: Path,
) -> dict[str, Path]:
    """Export all languages that have definitions.

    Returns dict mapping lang code to output file path.
    """
    langs = conn.execute(
        "SELECT DISTINCT lang FROM definitions ORDER BY lang"
    ).fetchall()

    results = {}
    for row in langs:
        lang = row["lang"]
        path = export_language(conn, lang, output_dir)
        results[lang] = path

    return results


def export_stats(conn: sqlite3.Connection) -> dict[str, int]:
    """Get entry counts per language for export."""
    rows = conn.execute("""
        SELECT d.lang, COUNT(DISTINCT d.headword_id) as count
        FROM definitions d
        GROUP BY d.lang
        ORDER BY d.lang
    """).fetchall()
    return {row["lang"]: row["count"] for row in rows}
